// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: items.sql

package dbgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countItems = `-- name: CountItems :one
SELECT COUNT(*) AS total
FROM items
WHERE
  ($1::text       IS NULL OR name ILIKE '%' || $1::text || '%')
  AND ($2::bigint IS NULL OR price_cents >= $2::bigint)
  AND ($3::bigint IS NULL OR price_cents <= $3::bigint)
`

type CountItemsParams struct {
	Name     pgtype.Text
	MinPrice pgtype.Int8
	MaxPrice pgtype.Int8
}

func (q *Queries) CountItems(ctx context.Context, arg CountItemsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countItems, arg.Name, arg.MinPrice, arg.MaxPrice)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const createItem = `-- name: CreateItem :one
INSERT INTO items (slug, name, description, price_cents, tags)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, slug, name, description, price_cents, tags, created_at, updated_at
`

type CreateItemParams struct {
	Slug        string
	Name        string
	Description string
	PriceCents  int64
	Tags        []string
}

func (q *Queries) CreateItem(ctx context.Context, arg CreateItemParams) (Item, error) {
	row := q.db.QueryRow(ctx, createItem,
		arg.Slug,
		arg.Name,
		arg.Description,
		arg.PriceCents,
		arg.Tags,
	)
	var i Item
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Name,
		&i.Description,
		&i.PriceCents,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getItemByID = `-- name: GetItemByID :one
SELECT id, slug, name, description, price_cents, tags, created_at, updated_at FROM items WHERE id = $1 LIMIT 1
`

func (q *Queries) GetItemByID(ctx context.Context, id int64) (Item, error) {
	row := q.db.QueryRow(ctx, getItemByID, id)
	var i Item
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Name,
		&i.Description,
		&i.PriceCents,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getItemByIDForUpdate = `-- name: GetItemByIDForUpdate :one
SELECT id, slug, name, description, price_cents, tags, created_at, updated_at FROM items WHERE id = $1 LIMIT 1 FOR UPDATE
`

func (q *Queries) GetItemByIDForUpdate(ctx context.Context, id int64) (Item, error) {
	row := q.db.QueryRow(ctx, getItemByIDForUpdate, id)
	var i Item
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Name,
		&i.Description,
		&i.PriceCents,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const patchItemOptimistic = `-- name: PatchItemOptimistic :one
UPDATE items AS i
SET
  name        = COALESCE($1::text,        i.name),
  description = COALESCE($2::text, i.description),
  price_cents = COALESCE($3::bigint,     i.price_cents),
  tags        = COALESCE($4::text[],      i.tags),
  updated_at  = now()
WHERE i.id = $5
  AND i.updated_at = $6::timestamptz
RETURNING id, slug, name, description, price_cents, tags, created_at, updated_at
`

type PatchItemOptimisticParams struct {
	Name          pgtype.Text
	Description   pgtype.Text
	Price         pgtype.Int8
	Tags          []string
	ID            int64
	PrevUpdatedAt pgtype.Timestamptz
}

func (q *Queries) PatchItemOptimistic(ctx context.Context, arg PatchItemOptimisticParams) (Item, error) {
	row := q.db.QueryRow(ctx, patchItemOptimistic,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.Tags,
		arg.ID,
		arg.PrevUpdatedAt,
	)
	var i Item
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Name,
		&i.Description,
		&i.PriceCents,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const searchItems = `-- name: SearchItems :many
SELECT id, slug, name, description, price_cents, tags, created_at, updated_at
FROM items
WHERE 
  ($1::text     IS NULL OR name ILIKE '%' || $1::text || '%') 
  AND ($2::bigint IS NULL OR price_cents >= $2::bigint)
  AND ($3::bigint IS NULL OR price_cents <= $3::bigint)
ORDER BY created_at DESC
LIMIT $5 OFFSET $4
`

type SearchItemsParams struct {
	Name     pgtype.Text
	MinPrice pgtype.Int8
	MaxPrice pgtype.Int8
	Offset   int32
	Limit    int32
}

func (q *Queries) SearchItems(ctx context.Context, arg SearchItemsParams) ([]Item, error) {
	rows, err := q.db.Query(ctx, searchItems,
		arg.Name,
		arg.MinPrice,
		arg.MaxPrice,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Item
	for rows.Next() {
		var i Item
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Name,
			&i.Description,
			&i.PriceCents,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchItemsKeysetNext = `-- name: SearchItemsKeysetNext :many
SELECT id, slug, name, description, price_cents, tags, created_at, updated_at
FROM items
WHERE
  ($1::text          IS NULL OR name ILIKE '%' || $1::text || '%')
  AND ($2::bigint IS NULL OR price_cents >= $2::bigint)
  AND ($3::bigint IS NULL OR price_cents <= $3::bigint)
  AND (
    $4::timestamptz IS NULL
    OR (created_at, id) < ($4::timestamptz, $5::bigint)
  )
ORDER BY created_at DESC, id DESC
LIMIT $6
`

type SearchItemsKeysetNextParams struct {
	Name           pgtype.Text
	MinPrice       pgtype.Int8
	MaxPrice       pgtype.Int8
	AfterCreatedAt pgtype.Timestamptz
	AfterID        pgtype.Int8
	Limit          int32
}

func (q *Queries) SearchItemsKeysetNext(ctx context.Context, arg SearchItemsKeysetNextParams) ([]Item, error) {
	rows, err := q.db.Query(ctx, searchItemsKeysetNext,
		arg.Name,
		arg.MinPrice,
		arg.MaxPrice,
		arg.AfterCreatedAt,
		arg.AfterID,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Item
	for rows.Next() {
		var i Item
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Name,
			&i.Description,
			&i.PriceCents,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchItemsKeysetPrev = `-- name: SearchItemsKeysetPrev :many
SELECT id, slug, name, description, price_cents, tags, created_at, updated_at
FROM items
WHERE
  ($1::text          IS NULL OR name ILIKE '%' || $1::text || '%')
  AND ($2::bigint IS NULL OR price_cents >= $2::bigint)
  AND ($3::bigint IS NULL OR price_cents <= $3::bigint)
  AND (
    $4::timestamptz IS NULL
    OR (created_at, id) > ($4::timestamptz, $5::bigint)
  )
ORDER BY created_at ASC, id ASC
LIMIT $6
`

type SearchItemsKeysetPrevParams struct {
	Name            pgtype.Text
	MinPrice        pgtype.Int8
	MaxPrice        pgtype.Int8
	BeforeCreatedAt pgtype.Timestamptz
	BeforeID        pgtype.Int8
	Limit           int32
}

func (q *Queries) SearchItemsKeysetPrev(ctx context.Context, arg SearchItemsKeysetPrevParams) ([]Item, error) {
	rows, err := q.db.Query(ctx, searchItemsKeysetPrev,
		arg.Name,
		arg.MinPrice,
		arg.MaxPrice,
		arg.BeforeCreatedAt,
		arg.BeforeID,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Item
	for rows.Next() {
		var i Item
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Name,
			&i.Description,
			&i.PriceCents,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertItemBySlug = `-- name: UpsertItemBySlug :one
INSERT INTO items (slug, name, description, price_cents, tags)
VALUES (
  $1,
  $2,
  $3,
  $4,
  $5::text[]
)
ON CONFLICT (slug) DO UPDATE
SET
  name        = EXCLUDED.name,
  description = EXCLUDED.description,
  price_cents = EXCLUDED.price_cents,
  tags        = EXCLUDED.tags,
  updated_at  = now()
RETURNING id, slug, name, description, price_cents, tags, created_at, updated_at
`

type UpsertItemBySlugParams struct {
	Slug        string
	Name        string
	Description string
	PriceCents  int64
	Tags        []string
}

func (q *Queries) UpsertItemBySlug(ctx context.Context, arg UpsertItemBySlugParams) (Item, error) {
	row := q.db.QueryRow(ctx, upsertItemBySlug,
		arg.Slug,
		arg.Name,
		arg.Description,
		arg.PriceCents,
		arg.Tags,
	)
	var i Item
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Name,
		&i.Description,
		&i.PriceCents,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
