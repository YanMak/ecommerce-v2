// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: certificates.sql

package dbgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteDocumentsByCertificate = `-- name: DeleteDocumentsByCertificate :exec
DELETE FROM certificate_documents
WHERE certificate_id = $1
`

func (q *Queries) DeleteDocumentsByCertificate(ctx context.Context, certificateID int64) error {
	_, err := q.db.Exec(ctx, deleteDocumentsByCertificate, certificateID)
	return err
}

const getCertificate = `-- name: GetCertificate :one
SELECT id, xml_id, title, created_by, updated_by, moved_by, created_time, updated_time, moved_time, category_id, opened, previous_stage_id, begindate, closedate, company_id, contact_id, opportunity, is_manual_opportunity, tax_value, currency_id, opportunity_account, tax_value_account, account_currency_id, mycompany_id, source_id, source_description, webform_id, uf_uuid, uf_inn, uf_company_name, uf_number, uf_start_date, uf_contract_date, uf_end_date, uf_status, uf_ids_documents, assigned_by_id, last_activity_by, last_activity_time, utm_source, utm_medium, utm_campaign, utm_content, utm_term, observers, contact_ids, entity_type_id
FROM certificates
WHERE id = $1
`

func (q *Queries) GetCertificate(ctx context.Context, id int64) (Certificate, error) {
	row := q.db.QueryRow(ctx, getCertificate, id)
	var i Certificate
	err := row.Scan(
		&i.ID,
		&i.XmlID,
		&i.Title,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.MovedBy,
		&i.CreatedTime,
		&i.UpdatedTime,
		&i.MovedTime,
		&i.CategoryID,
		&i.Opened,
		&i.PreviousStageID,
		&i.Begindate,
		&i.Closedate,
		&i.CompanyID,
		&i.ContactID,
		&i.Opportunity,
		&i.IsManualOpportunity,
		&i.TaxValue,
		&i.CurrencyID,
		&i.OpportunityAccount,
		&i.TaxValueAccount,
		&i.AccountCurrencyID,
		&i.MycompanyID,
		&i.SourceID,
		&i.SourceDescription,
		&i.WebformID,
		&i.UfUuid,
		&i.UfInn,
		&i.UfCompanyName,
		&i.UfNumber,
		&i.UfStartDate,
		&i.UfContractDate,
		&i.UfEndDate,
		&i.UfStatus,
		&i.UfIdsDocuments,
		&i.AssignedByID,
		&i.LastActivityBy,
		&i.LastActivityTime,
		&i.UtmSource,
		&i.UtmMedium,
		&i.UtmCampaign,
		&i.UtmContent,
		&i.UtmTerm,
		&i.Observers,
		&i.ContactIds,
		&i.EntityTypeID,
	)
	return i, err
}

const listCertificatesUpdatedSince = `-- name: ListCertificatesUpdatedSince :many
SELECT id, xml_id, title, created_by, updated_by, moved_by, created_time, updated_time, moved_time, category_id, opened, previous_stage_id, begindate, closedate, company_id, contact_id, opportunity, is_manual_opportunity, tax_value, currency_id, opportunity_account, tax_value_account, account_currency_id, mycompany_id, source_id, source_description, webform_id, uf_uuid, uf_inn, uf_company_name, uf_number, uf_start_date, uf_contract_date, uf_end_date, uf_status, uf_ids_documents, assigned_by_id, last_activity_by, last_activity_time, utm_source, utm_medium, utm_campaign, utm_content, utm_term, observers, contact_ids, entity_type_id
FROM certificates
WHERE updated_time >= $1
ORDER BY updated_time ASC
LIMIT $2 OFFSET $3
`

type ListCertificatesUpdatedSinceParams struct {
	UpdatedTime pgtype.Timestamptz `db:"updated_time" json:"updated_time"`
	Limit       int32              `db:"limit" json:"limit"`
	Offset      int32              `db:"offset" json:"offset"`
}

func (q *Queries) ListCertificatesUpdatedSince(ctx context.Context, arg ListCertificatesUpdatedSinceParams) ([]Certificate, error) {
	rows, err := q.db.Query(ctx, listCertificatesUpdatedSince, arg.UpdatedTime, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Certificate
	for rows.Next() {
		var i Certificate
		if err := rows.Scan(
			&i.ID,
			&i.XmlID,
			&i.Title,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.MovedBy,
			&i.CreatedTime,
			&i.UpdatedTime,
			&i.MovedTime,
			&i.CategoryID,
			&i.Opened,
			&i.PreviousStageID,
			&i.Begindate,
			&i.Closedate,
			&i.CompanyID,
			&i.ContactID,
			&i.Opportunity,
			&i.IsManualOpportunity,
			&i.TaxValue,
			&i.CurrencyID,
			&i.OpportunityAccount,
			&i.TaxValueAccount,
			&i.AccountCurrencyID,
			&i.MycompanyID,
			&i.SourceID,
			&i.SourceDescription,
			&i.WebformID,
			&i.UfUuid,
			&i.UfInn,
			&i.UfCompanyName,
			&i.UfNumber,
			&i.UfStartDate,
			&i.UfContractDate,
			&i.UfEndDate,
			&i.UfStatus,
			&i.UfIdsDocuments,
			&i.AssignedByID,
			&i.LastActivityBy,
			&i.LastActivityTime,
			&i.UtmSource,
			&i.UtmMedium,
			&i.UtmCampaign,
			&i.UtmContent,
			&i.UtmTerm,
			&i.Observers,
			&i.ContactIds,
			&i.EntityTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDocumentsForCertificate = `-- name: ListDocumentsForCertificate :many
SELECT id, certificate_id, url, url_machine, created_at
FROM certificate_documents
WHERE certificate_id = $1
ORDER BY id ASC
`

func (q *Queries) ListDocumentsForCertificate(ctx context.Context, certificateID int64) ([]CertificateDocument, error) {
	rows, err := q.db.Query(ctx, listDocumentsForCertificate, certificateID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CertificateDocument
	for rows.Next() {
		var i CertificateDocument
		if err := rows.Scan(
			&i.ID,
			&i.CertificateID,
			&i.Url,
			&i.UrlMachine,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchCertificates = `-- name: SearchCertificates :many
SELECT id, xml_id, title, created_by, updated_by, moved_by, created_time, updated_time, moved_time, category_id, opened, previous_stage_id, begindate, closedate, company_id, contact_id, opportunity, is_manual_opportunity, tax_value, currency_id, opportunity_account, tax_value_account, account_currency_id, mycompany_id, source_id, source_description, webform_id, uf_uuid, uf_inn, uf_company_name, uf_number, uf_start_date, uf_contract_date, uf_end_date, uf_status, uf_ids_documents, assigned_by_id, last_activity_by, last_activity_time, utm_source, utm_medium, utm_campaign, utm_content, utm_term, observers, contact_ids, entity_type_id
FROM certificates
WHERE ($1::TEXT IS NULL OR uf_number ILIKE '%' || $1 || '%')
  AND ($2::TEXT IS NULL OR uf_inn = $2)
ORDER BY updated_time DESC
LIMIT $3 OFFSET $4
`

type SearchCertificatesParams struct {
	Column1 string `db:"column_1" json:"column_1"`
	Column2 string `db:"column_2" json:"column_2"`
	Limit   int32  `db:"limit" json:"limit"`
	Offset  int32  `db:"offset" json:"offset"`
}

// Поиск по номеру сертификата (частичное совпадение, case-insensitive) и/или ИНН.
func (q *Queries) SearchCertificates(ctx context.Context, arg SearchCertificatesParams) ([]Certificate, error) {
	rows, err := q.db.Query(ctx, searchCertificates,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Certificate
	for rows.Next() {
		var i Certificate
		if err := rows.Scan(
			&i.ID,
			&i.XmlID,
			&i.Title,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.MovedBy,
			&i.CreatedTime,
			&i.UpdatedTime,
			&i.MovedTime,
			&i.CategoryID,
			&i.Opened,
			&i.PreviousStageID,
			&i.Begindate,
			&i.Closedate,
			&i.CompanyID,
			&i.ContactID,
			&i.Opportunity,
			&i.IsManualOpportunity,
			&i.TaxValue,
			&i.CurrencyID,
			&i.OpportunityAccount,
			&i.TaxValueAccount,
			&i.AccountCurrencyID,
			&i.MycompanyID,
			&i.SourceID,
			&i.SourceDescription,
			&i.WebformID,
			&i.UfUuid,
			&i.UfInn,
			&i.UfCompanyName,
			&i.UfNumber,
			&i.UfStartDate,
			&i.UfContractDate,
			&i.UfEndDate,
			&i.UfStatus,
			&i.UfIdsDocuments,
			&i.AssignedByID,
			&i.LastActivityBy,
			&i.LastActivityTime,
			&i.UtmSource,
			&i.UtmMedium,
			&i.UtmCampaign,
			&i.UtmContent,
			&i.UtmTerm,
			&i.Observers,
			&i.ContactIds,
			&i.EntityTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertCertificate = `-- name: UpsertCertificate :exec
INSERT INTO certificates (
  id, xml_id, title,
  created_by, updated_by, moved_by,
  created_time, updated_time, moved_time,
  category_id, opened, previous_stage_id,
  begindate, closedate,
  company_id, contact_id,
  opportunity, is_manual_opportunity, tax_value,
  currency_id, opportunity_account, tax_value_account, account_currency_id,
  mycompany_id,
  source_id, source_description, webform_id,
  uf_uuid, uf_inn, uf_company_name, uf_number,
  uf_start_date, uf_contract_date, uf_end_date,
  uf_status, uf_ids_documents,
  assigned_by_id, last_activity_by, last_activity_time,
  utm_source, utm_medium, utm_campaign, utm_content, utm_term,
  observers, contact_ids,
  entity_type_id
) VALUES (
  $1, $2, $3,
  $4, $5, $6,
  $7, $8, $9,
  $10, $11, $12,
  $13, $14,
  $15, $16,
  $17, $18, $19,
  $20, $21, $22, $23,
  $24,
  $25, $26, $27,
  $28, $29, $30, $31,
  $32, $33, $34,
  $35, $36,
  $37, $38, $39,
  $40, $41, $42, $43, $44,
  $45, $46,
  $47
)
ON CONFLICT (id) DO UPDATE SET
  xml_id = EXCLUDED.xml_id,
  title = EXCLUDED.title,
  created_by = EXCLUDED.created_by,
  updated_by = EXCLUDED.updated_by,
  moved_by = EXCLUDED.moved_by,
  created_time = EXCLUDED.created_time,
  updated_time = EXCLUDED.updated_time,
  moved_time = EXCLUDED.moved_time,
  category_id = EXCLUDED.category_id,
  opened = EXCLUDED.opened,
  previous_stage_id = EXCLUDED.previous_stage_id,
  begindate = EXCLUDED.begindate,
  closedate = EXCLUDED.closedate,
  company_id = EXCLUDED.company_id,
  contact_id = EXCLUDED.contact_id,
  opportunity = EXCLUDED.opportunity,
  is_manual_opportunity = EXCLUDED.is_manual_opportunity,
  tax_value = EXCLUDED.tax_value,
  currency_id = EXCLUDED.currency_id,
  opportunity_account = EXCLUDED.opportunity_account,
  tax_value_account = EXCLUDED.tax_value_account,
  account_currency_id = EXCLUDED.account_currency_id,
  mycompany_id = EXCLUDED.mycompany_id,
  source_id = EXCLUDED.source_id,
  source_description = EXCLUDED.source_description,
  webform_id = EXCLUDED.webform_id,
  uf_uuid = EXCLUDED.uf_uuid,
  uf_inn = EXCLUDED.uf_inn,
  uf_company_name = EXCLUDED.uf_company_name,
  uf_number = EXCLUDED.uf_number,
  uf_start_date = EXCLUDED.uf_start_date,
  uf_contract_date = EXCLUDED.uf_contract_date,
  uf_end_date = EXCLUDED.uf_end_date,
  uf_status = EXCLUDED.uf_status,
  uf_ids_documents = EXCLUDED.uf_ids_documents,
  assigned_by_id = EXCLUDED.assigned_by_id,
  last_activity_by = EXCLUDED.last_activity_by,
  last_activity_time = EXCLUDED.last_activity_time,
  utm_source = EXCLUDED.utm_source,
  utm_medium = EXCLUDED.utm_medium,
  utm_campaign = EXCLUDED.utm_campaign,
  utm_content = EXCLUDED.utm_content,
  utm_term = EXCLUDED.utm_term,
  observers = EXCLUDED.observers,
  contact_ids = EXCLUDED.contact_ids,
  entity_type_id = EXCLUDED.entity_type_id
`

type UpsertCertificateParams struct {
	ID                  int64              `db:"id" json:"id"`
	XmlID               pgtype.Text        `db:"xml_id" json:"xml_id"`
	Title               string             `db:"title" json:"title"`
	CreatedBy           int64              `db:"created_by" json:"created_by"`
	UpdatedBy           int64              `db:"updated_by" json:"updated_by"`
	MovedBy             int64              `db:"moved_by" json:"moved_by"`
	CreatedTime         pgtype.Timestamptz `db:"created_time" json:"created_time"`
	UpdatedTime         pgtype.Timestamptz `db:"updated_time" json:"updated_time"`
	MovedTime           pgtype.Timestamptz `db:"moved_time" json:"moved_time"`
	CategoryID          int64              `db:"category_id" json:"category_id"`
	Opened              bool               `db:"opened" json:"opened"`
	PreviousStageID     pgtype.Text        `db:"previous_stage_id" json:"previous_stage_id"`
	Begindate           pgtype.Timestamptz `db:"begindate" json:"begindate"`
	Closedate           pgtype.Timestamptz `db:"closedate" json:"closedate"`
	CompanyID           pgtype.Int8        `db:"company_id" json:"company_id"`
	ContactID           pgtype.Int8        `db:"contact_id" json:"contact_id"`
	Opportunity         pgtype.Numeric     `db:"opportunity" json:"opportunity"`
	IsManualOpportunity bool               `db:"is_manual_opportunity" json:"is_manual_opportunity"`
	TaxValue            pgtype.Numeric     `db:"tax_value" json:"tax_value"`
	CurrencyID          pgtype.Text        `db:"currency_id" json:"currency_id"`
	OpportunityAccount  pgtype.Numeric     `db:"opportunity_account" json:"opportunity_account"`
	TaxValueAccount     pgtype.Numeric     `db:"tax_value_account" json:"tax_value_account"`
	AccountCurrencyID   pgtype.Text        `db:"account_currency_id" json:"account_currency_id"`
	MycompanyID         pgtype.Int8        `db:"mycompany_id" json:"mycompany_id"`
	SourceID            pgtype.Text        `db:"source_id" json:"source_id"`
	SourceDescription   pgtype.Text        `db:"source_description" json:"source_description"`
	WebformID           pgtype.Int8        `db:"webform_id" json:"webform_id"`
	UfUuid              pgtype.UUID        `db:"uf_uuid" json:"uf_uuid"`
	UfInn               pgtype.Text        `db:"uf_inn" json:"uf_inn"`
	UfCompanyName       pgtype.Text        `db:"uf_company_name" json:"uf_company_name"`
	UfNumber            pgtype.Text        `db:"uf_number" json:"uf_number"`
	UfStartDate         pgtype.Timestamptz `db:"uf_start_date" json:"uf_start_date"`
	UfContractDate      pgtype.Timestamptz `db:"uf_contract_date" json:"uf_contract_date"`
	UfEndDate           pgtype.Timestamptz `db:"uf_end_date" json:"uf_end_date"`
	UfStatus            pgtype.Int8        `db:"uf_status" json:"uf_status"`
	UfIdsDocuments      pgtype.Text        `db:"uf_ids_documents" json:"uf_ids_documents"`
	AssignedByID        pgtype.Int8        `db:"assigned_by_id" json:"assigned_by_id"`
	LastActivityBy      pgtype.Int8        `db:"last_activity_by" json:"last_activity_by"`
	LastActivityTime    pgtype.Timestamptz `db:"last_activity_time" json:"last_activity_time"`
	UtmSource           pgtype.Text        `db:"utm_source" json:"utm_source"`
	UtmMedium           pgtype.Text        `db:"utm_medium" json:"utm_medium"`
	UtmCampaign         pgtype.Text        `db:"utm_campaign" json:"utm_campaign"`
	UtmContent          pgtype.Text        `db:"utm_content" json:"utm_content"`
	UtmTerm             pgtype.Text        `db:"utm_term" json:"utm_term"`
	Observers           []int32            `db:"observers" json:"observers"`
	ContactIds          []int32            `db:"contact_ids" json:"contact_ids"`
	EntityTypeID        int64              `db:"entity_type_id" json:"entity_type_id"`
}

func (q *Queries) UpsertCertificate(ctx context.Context, arg UpsertCertificateParams) error {
	_, err := q.db.Exec(ctx, upsertCertificate,
		arg.ID,
		arg.XmlID,
		arg.Title,
		arg.CreatedBy,
		arg.UpdatedBy,
		arg.MovedBy,
		arg.CreatedTime,
		arg.UpdatedTime,
		arg.MovedTime,
		arg.CategoryID,
		arg.Opened,
		arg.PreviousStageID,
		arg.Begindate,
		arg.Closedate,
		arg.CompanyID,
		arg.ContactID,
		arg.Opportunity,
		arg.IsManualOpportunity,
		arg.TaxValue,
		arg.CurrencyID,
		arg.OpportunityAccount,
		arg.TaxValueAccount,
		arg.AccountCurrencyID,
		arg.MycompanyID,
		arg.SourceID,
		arg.SourceDescription,
		arg.WebformID,
		arg.UfUuid,
		arg.UfInn,
		arg.UfCompanyName,
		arg.UfNumber,
		arg.UfStartDate,
		arg.UfContractDate,
		arg.UfEndDate,
		arg.UfStatus,
		arg.UfIdsDocuments,
		arg.AssignedByID,
		arg.LastActivityBy,
		arg.LastActivityTime,
		arg.UtmSource,
		arg.UtmMedium,
		arg.UtmCampaign,
		arg.UtmContent,
		arg.UtmTerm,
		arg.Observers,
		arg.ContactIds,
		arg.EntityTypeID,
	)
	return err
}

const upsertDocument = `-- name: UpsertDocument :exec
INSERT INTO certificate_documents (id, certificate_id, url, url_machine)
VALUES ($1, $2, $3, $4)
ON CONFLICT (id) DO UPDATE SET
  certificate_id = EXCLUDED.certificate_id,
  url = EXCLUDED.url,
  url_machine = EXCLUDED.url_machine
`

type UpsertDocumentParams struct {
	ID            int64  `db:"id" json:"id"`
	CertificateID int64  `db:"certificate_id" json:"certificate_id"`
	Url           string `db:"url" json:"url"`
	UrlMachine    string `db:"url_machine" json:"url_machine"`
}

func (q *Queries) UpsertDocument(ctx context.Context, arg UpsertDocumentParams) error {
	_, err := q.db.Exec(ctx, upsertDocument,
		arg.ID,
		arg.CertificateID,
		arg.Url,
		arg.UrlMachine,
	)
	return err
}
